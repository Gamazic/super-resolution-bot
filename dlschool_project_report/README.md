# Курсовой проект `dlschool` по теме `Улучшение качества фотографий`

## Связь с автором

В слаке https://dls-community.slack.com/archives/D02T4QRLPCG

## Постановка задачи

В рамках задачи было необходимо создать телеграм-бота, который будет улучшать качество отправленных фотографий.
Улучшение фотографий должно производится с помощью `GAN`.

## Проделенная работа

* Создан асинхронный телеграм-бот с помощью фреймворка `aiogram`. Асинхронность проявляется в возможности обрабатывать сообщения пользователей.
* Интегрирована модель `Sber Real-ESRGAN`. Модель представляет из себя генеративную сеть `ESRGAN`.
* Т.к. вызов модели - `CPU BOUND` блокирующая задача и просто вызывать модель в коде бота нельзя - пришлось внедрить фреймворк `Celery`. Он позволяет выполнять задачи из очереди в бэкграунде. В качестве брокера сообщений для очереди был взят `Redis`.
* Все сервисы упакованы в `docker-compose`.

## Бот

Функциональность:
* Start message. Когда пользователь впервые начинает общение с ботом, ему отправляется стартовое сообщение с инструкцией пользования.
* Улучшение качества пересланной фотографии. Бот принимает фотографию, отправляет пользователю сообщение о том, что фотография успешно получена и по завершению обработки изображения, улучшенное изображение отправляется пользователю.

Особых проблем в этой части у меня не возникло, т.к. у меня есть опыт работы с `aiogram`.

## Модель

Итоговая модель была взята из этого репозитория: https://github.com/sberbank-ai/Real-ESRGAN

Статья из архифа с описанием модели: https://arxiv.org/abs/2107.10833

`Real-ESRGAN` по сути не является моделью, а лишь подходом к построению обучающей выборки. Суть которого заключается в генерации наиболее "реалистичных" уменьшенных версий изображений. Оригинальная модель `ESRGAN` облада изьянами из за чисто синтетической выборки.

Было довольно сложно найти обзорные статьи по всем имеющимся подходам к super resolution.

Я нашел маленький обзор по данной ссылке: https://github.com/sgrvinod/a-PyTorch-Tutorial-to-Super-Resolution

После этого стал вдаваться в подробности `SRGAN`, т.к. он показывает визуально более хорошее качество. После такого "разведовочного анализа" я нашел модель `ESRGAN`, которая предлагала улучшения в архитектуре и в результатах. Дальше захотелось узнать, есть ли что то новее и лучше этого и наткнулся на `Real-ESRGAN`. Результаты понравились гораздо сильнее. Особенно аниме. Также посмотрел, что рекомендуют на `ods`. Там тоже рекомендовали `Real-ESRGAN`. Модель сбера взял опять же потому что больше понравилось качество улучшенных изображений.

## Celery

Здесь была основная проблема программирования проекта. Т.к. ранее у меня не было опыта с комбинированием `CPU BOUND` и `IO BOUND` задач, я очень много времени потратил, чтобы разобраться, как подружить эти задачи.

Дело в том, что если вызывать модель внутри бота, тогда это будет блокирующей задачей. Значит и `async io` не будет правильно работать.

Изначально я пробовал отправлять модель в другой поток, как в данном туториале: https://medium.com/@vladbezden/execute-blocking-code-on-a-different-thread-using-asyncio-db4baa956d1f.
Но это приводило к проблемам, что если много раз вызвать модель в короткий промежуток времени, тогда обработка всех сообщений будет затягиваться непропорционально долго. А ответ для всех сообщений будет в один момент времени. Стало ясно, что нужно использовать концепцию очереди. Так я и пришел к `Celery`.

`Celery` позволяет класть задачи в очередь и исполнять их в бэкграунде(в отедельном потоке). В результате, если вызывать модель много раз в короткий промежуток времени, то все задачи просто будут кластся в очередь и исполняться по порядку. При этом производительность не падает, как в случае с созданием нового потока под каждый вызов.
